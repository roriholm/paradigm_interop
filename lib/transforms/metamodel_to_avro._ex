defmodule Paradigm.Transform.Canonical.MetamodelToAvro do
  @behaviour Paradigm.Transform

  @type_mappings %{
    "integer" => "int",
    "void" => "null"
  }

  @impl true
  def transform(source_graph) do
    with {:ok, graph} <- do_transform(source_graph) do
      {:ok, graph}
    end
  rescue
    e -> {:error, Exception.message(e)}
  end

  defp do_transform(source_graph) do
    {:ok, source_graph
    |> transform_classes()
    |> transform_enumerations()
    |> Paradigm.Canonical.Avro.inject_primitive_nodes()}
  end

  defp transform_classes(source_graph) do
    find_nodes_by_class(source_graph, "class")
    |> Enum.reduce(%{}, &process_class(&1, &2, source_graph))
  end

  defp process_class({id, _node}, acc, source_graph) do
    fields = get_node_data(source_graph, id, "owned_attributes")

    acc
    |> add_record_node(id, source_graph, fields)
    |> add_field_nodes(fields, source_graph)
  end

  defp add_record_node(acc, id, source_graph, fields) do
    Map.put(acc, id, %Paradigm.Graph.Node{
      class: "record",
      data: %{
        "name" => get_node_data(source_graph, id, "name"),
        "aliases" => [],
        "fields" => fields,
        "doc" => nil,
        "namespace" => nil
      }
    })
  end

  defp add_field_nodes(acc, fields, source_graph) do
    Enum.reduce(fields, acc, fn prop_id, acc ->
      name = get_node_data(source_graph, prop_id, "name")
      type = get_property_type(get_node_data(source_graph, prop_id, "type"))
      upper_bound = get_node_data(source_graph, prop_id, "upper_bound")
      default = get_node_data(source_graph, prop_id, "default_value")
      is_array = (upper_bound == :infinity or upper_bound > 1)
      if is_array do

        acc
        |> Map.put("#{type}_array", %Paradigm.Graph.Node{
          class: "array",
          data: %{
            "name" => "#{type}_array",
            "items" => type
          }
        })
        |> Map.put(prop_id, %Paradigm.Graph.Node{
            class: "field",
            data: %{
              "name" => name,
              "type" => "#{type}_array",
              "aliases" => [],
              "default" => default,
              "doc" => nil
            }
          })

      else
        Map.put(acc, prop_id, %Paradigm.Graph.Node{
          class: "field",
          data: %{
            "name" => name,
            "type" => type,
            "aliases" => [],
            "default" => default,
            "doc" => nil
          }
        })
      end
    end)
  end

  defp transform_enumerations(graph) do
    find_nodes_by_class(graph, "enumeration")
    |> Enum.reduce(graph, &add_enum_node(&1, &2))
  end

  defp add_enum_node({id, _node}, acc) do
    Map.put(acc, "enum_#{id}", %Paradigm.Graph.Node{
      class: "enum",
      data: %{
        "name" => get_node_data(acc, id, "name"),
        "namespace" => "metamodel",
        "symbols" => get_enum_symbols(acc, get_node_data(acc, id, "literals"))
      }
    })
  end

  defp get_enum_symbols(graph, literal_ids) when is_list(literal_ids) do
    Enum.map(literal_ids, &get_node_data(graph, &1, "name"))
  end
  defp get_enum_symbols(_, _), do: []

  defp get_property_type(type) do
    Map.get(@type_mappings, type, type)
  end
end
