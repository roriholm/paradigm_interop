defmodule Paradigm.Transform.Canonical.ThriftToMetamodel do
  @behaviour Paradigm.Transform

  @type_mapping %{
    "bool" => "boolean",
    "byte" => "integer",
    "i8" => "integer",
    "i16" => "integer",
    "i32" => "integer",
    "i64" => "integer",
    "double" => "float",
    "string" => "string",
    "binary" => "string",
    "uuid" => "string"
  }

  @impl true
  def transform(graph) do
    # Build union type mapping first
    union_mapping = graph
    |> Paradigm.Graph.find_nodes_by_class(["union"])
    |> Enum.reduce(%{}, &build_union_mapping(&1, &2, graph))

    primitives = Paradigm.Canonical.primitive_nodes()
    # Process unions as abstract classes
    metamodel_graph_with_unions = graph
    |> Paradigm.Graph.find_nodes_by_class(["union"])
    |> Enum.reduce(primitives, &(convert_union_node(&1, &2, graph)))

    # Then process structs with union mapping
    metamodel_graph = graph
    |> Paradigm.Graph.find_nodes_by_class(["struct"])
    |> Enum.reduce(metamodel_graph_with_unions, &(convert_type_node(&1, &2, graph, union_mapping)))
    #|> Paradigm.Canonical.inject_primitives()

    {:ok, metamodel_graph}
  end

  defp build_union_mapping({id, node}, acc, graph) do
    class_name = Paradigm.Graph.get_node_data(graph, id, "name")
    fields = Paradigm.Graph.get_node_data(graph, id, "fields", [])

    Enum.reduce(fields, acc, fn field_id, union_acc ->
      field_type = Paradigm.Graph.get_node_data(graph, field_id, "type")
      case Map.get(union_acc, field_type) do
        nil -> Map.put(union_acc, field_type, [id])
        existing -> Map.put(union_acc, field_type, [id | existing])
      end
    end)
  end

  defp convert_union_node({id, node}, acc, graph) do
    class_id = to_string(id)
    class_name = Paradigm.Graph.get_node_data(graph, id, "name")

    Map.put(acc, class_id, %Paradigm.Graph.Node{
      class: "class",
      data: %{
        "name" => class_name,
        "is_abstract" => true,
        "owned_attributes" => [],
        "super_classes" => []
      }
    })
  end

  defp convert_type_node({id, node}, acc, graph, union_mapping) do
    class_id = to_string(id)
    class_name = Paradigm.Graph.get_node_data(graph, id, "name")

    {acc_with_props, properties} = graph
    |> Paradigm.Graph.get_node_data(id, "fields", [])
    |> Enum.reduce({acc, []}, &convert_field(&1, &2, graph))

    Map.put(acc_with_props, class_id, %Paradigm.Graph.Node{
      class: "class",
      data: %{
        "name" => class_name,
        "is_abstract" => false,
        "owned_attributes" => properties,
        "super_classes" => Map.get(union_mapping, class_id, [])
      }
    })
  end

  defp convert_field(field_id, {acc, properties}, graph) do
    property_id = to_string(field_id)
    field_data = %{
      name: Paradigm.Graph.get_node_data(graph, field_id, "name"),
      type: Paradigm.Graph.get_node_data(graph, field_id, "type"),
      required: Paradigm.Graph.get_node_data(graph, field_id, "required"),
      is_list: Paradigm.Graph.get_node_data(graph, field_id, "is_list"),
      default: Paradigm.Graph.get_node_data(graph, field_id, "default")
    }

    acc = Map.put(acc, property_id, create_property_node(field_data))
    {acc, properties ++ [property_id]}
  end

  defp create_property_node(%{name: name, type: type, required: required, is_list: is_list, default: default}) do
    %Paradigm.Graph.Node{
      class: "property",
      data: %{
        "name" => name,
        "type" => convert_type(type),
        "is_ordered" => is_list,
        "is_composite" => is_list,
        "lower_bound" => if(required, do: 1, else: 0),
        "upper_bound" => if(is_list, do: :infinity, else: 1),
        "default_value" => default
      }
    }
  end

  defp convert_type(type) do
    Map.get(@type_mapping, type, type)
  end
end
